<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>ベビーモニター（同一Wi-Fi / QRなし / 自動接続）</title>

  <script src="https://cdn.tailwindcss.com"></script>

  <style>
    body { -webkit-tap-highlight-color: transparent; }
    video { background:#000; }
    .night { filter: brightness(1.9) contrast(1.45) saturate(0.85); }
  </style>
</head>

<body class="bg-slate-50 text-slate-800">
  <div class="max-w-5xl mx-auto p-4 space-y-4">
    <!-- Header -->
    <header class="space-y-2">
      <div class="flex items-center justify-between gap-2 flex-wrap">
        <div class="text-xl sm:text-2xl font-black">ベビーモニター（同一Wi-Fi / 自動接続 / QRなし）</div>
        <div id="badge" class="text-xs font-black px-3 py-1 rounded-full border bg-white text-slate-700 border-slate-200">
          準備中
        </div>
      </div>
      <div class="text-xs text-slate-500 leading-relaxed">
        ※HTTPS必須（GitHub Pages等）。<br/>
        ※この版は「接続の待ち合わせ」に Firestore を使います（映像/音声は基本ローカル直結を狙います）。<br/>
        ※医療機器ではありません。短時間の補助用途を想定しています。
      </div>
    </header>

    <!-- Mode -->
    <section class="bg-white rounded-3xl border border-slate-200 p-4 space-y-3 shadow-sm">
      <div class="flex items-center justify-between gap-2 flex-wrap">
        <div class="font-black text-slate-700">0）モード</div>
        <div class="text-xs text-slate-500">「送信開始」→ 受信側で「受信開始」だけで自動接続</div>
      </div>

      <div class="grid sm:grid-cols-2 gap-3">
        <button id="btnModeSend" class="p-4 rounded-3xl border border-slate-200 bg-white hover:bg-slate-50 active:scale-[0.99] text-left">
          <div class="text-lg font-black">👶 送信（ベビー側）</div>
          <div class="text-xs text-slate-500 mt-1">カメラ＋マイクを配信</div>
        </button>
        <button id="btnModeRecv" class="p-4 rounded-3xl border border-slate-200 bg-white hover:bg-slate-50 active:scale-[0.99] text-left">
          <div class="text-lg font-black">👀 受信（見守り側）</div>
          <div class="text-xs text-slate-500 mt-1">受信映像を表示（iOSは▶再生で安定）</div>
        </button>
      </div>

      <div class="flex items-center justify-between gap-2 flex-wrap">
        <div class="text-sm">状態：<span id="state" class="font-black">待機中</span></div>
        <div class="text-xs text-slate-500">端末：<span id="uaHint"></span></div>
      </div>
    </section>

    <!-- SEND -->
    <section id="sendView" class="hidden space-y-4">
      <section class="bg-white rounded-3xl border border-slate-200 p-4 space-y-4 shadow-sm">
        <div class="flex items-center justify-between gap-2 flex-wrap">
          <div class="font-black text-slate-700">送信（ベビー側）</div>
          <div class="flex gap-2">
            <button id="btnSendStart" class="px-4 py-2 rounded-2xl bg-indigo-600 text-white font-black active:scale-[0.99]">
              配信開始
            </button>
            <button id="btnSendStop" class="px-4 py-2 rounded-2xl bg-slate-200 font-black active:scale-[0.99]" disabled>
              停止
            </button>
          </div>
        </div>

        <div class="grid lg:grid-cols-2 gap-4">
          <div class="space-y-2">
            <div class="flex items-center justify-between">
              <div class="text-sm font-bold text-slate-600">プレビュー</div>
              <button id="btnFullLocal" class="px-3 py-2 rounded-2xl border border-slate-200 bg-white font-bold active:scale-[0.99]" disabled>⛶ 全画面</button>
            </div>
            <video id="localVideo" class="w-full rounded-3xl aspect-video" playsinline muted autoplay></video>

            <div class="grid grid-cols-2 gap-2">
              <button id="btnFlipCam" class="px-3 py-2 rounded-2xl border border-slate-200 bg-white font-bold active:scale-[0.99]" disabled>📷 前/後切替</button>
              <button id="btnMicMute" class="px-3 py-2 rounded-2xl border border-slate-200 bg-white font-bold active:scale-[0.99]" disabled>🎤 マイク：ON</button>
              <button id="btnNightLocal" class="px-3 py-2 rounded-2xl border border-slate-200 bg-white font-bold active:scale-[0.99]" disabled>🌙 暗視：OFF</button>
              <button id="btnTorch" class="px-3 py-2 rounded-2xl border border-slate-200 bg-white font-bold active:scale-[0.99]" disabled>🔦 ライト：OFF</button>
            </div>

            <div class="bg-slate-50 border border-slate-200 rounded-2xl p-3 text-xs text-slate-600">
              <div class="font-bold text-slate-700 mb-1">撮影設定</div>
              <div id="camInfo">未開始</div>
              <div class="mt-1 text-slate-500">※最高画質を要求し、端末が可能な最大に寄せます。</div>
            </div>

            <div class="text-xs text-slate-500">
              ※暗視は「疑似（明るさ/コントラスト強調）」です。赤外線暗視は端末ハード依存でWebから追加できません。
            </div>
          </div>

          <div class="space-y-3">
            <div class="bg-indigo-50 border border-indigo-200 rounded-2xl p-3">
              <div class="font-black text-indigo-900">接続の流れ</div>
              <ol class="mt-2 text-sm text-indigo-800 space-y-1 list-decimal pl-5">
                <li>この端末で「配信開始」</li>
                <li>見守り端末で「受信開始」</li>
                <li>自動でつながります</li>
              </ol>
            </div>

            <div class="bg-slate-50 border border-slate-200 rounded-2xl p-3 text-sm">
              <div class="font-black text-slate-700">接続状態</div>
              <div class="mt-1">Peer：<span id="sendConn" class="font-black">未接続</span></div>
              <div class="text-xs text-slate-500 mt-1">※同じWi-Fiでも「端末隔離」があると接続できません。</div>
            </div>

            <div class="bg-amber-50 border border-amber-200 rounded-2xl p-3 text-xs text-amber-800">
              💡 つながらない時：Wi-Fiが「ゲスト」になっていないか／端末隔離がないかを確認してください。
            </div>
          </div>
        </div>
      </section>
    </section>

    <!-- RECV -->
    <section id="recvView" class="hidden space-y-4">
      <section class="bg-white rounded-3xl border border-slate-200 p-4 space-y-4 shadow-sm">
        <div class="flex items-center justify-between gap-2 flex-wrap">
          <div class="font-black text-slate-700">受信（見守り側）</div>
          <div class="flex gap-2">
            <button id="btnRecvStart" class="px-4 py-2 rounded-2xl bg-emerald-600 text-white font-black active:scale-[0.99]">
              受信開始
            </button>
            <button id="btnRecvStop" class="px-4 py-2 rounded-2xl bg-slate-200 font-black active:scale-[0.99]" disabled>
              停止
            </button>
          </div>
        </div>

        <div class="grid lg:grid-cols-2 gap-4">
          <div class="space-y-2">
            <div class="flex items-center justify-between">
              <div class="text-sm font-bold text-slate-600">受信映像</div>
              <button id="btnFullRemote" class="px-3 py-2 rounded-2xl border border-slate-200 bg-white font-bold active:scale-[0.99]" disabled>⛶ 全画面</button>
            </div>
            <video id="remoteVideo" class="w-full rounded-3xl aspect-video" playsinline autoplay></video>

            <div class="grid grid-cols-2 gap-2">
              <button id="btnPlayRemote" class="px-3 py-2 rounded-2xl bg-emerald-600 text-white font-black active:scale-[0.99]" disabled>▶ 再生</button>
              <button id="btnSpkMute" class="px-3 py-2 rounded-2xl border border-slate-200 bg-white font-bold active:scale-[0.99]" disabled>🔈 音：ON</button>
              <button id="btnNightRemote" class="px-3 py-2 rounded-2xl border border-slate-200 bg-white font-bold active:scale-[0.99]" disabled>🌙 暗視：OFF</button>
              <button id="btnFullAlt" class="px-3 py-2 rounded-2xl border border-slate-200 bg-white font-bold active:scale-[0.99]" disabled>⛶（代替）</button>
            </div>

            <div class="bg-slate-50 border border-slate-200 rounded-2xl p-3 text-xs text-slate-600">
              <div class="font-bold text-slate-700 mb-1">メモ</div>
              <ul class="list-disc pl-5 space-y-1">
                <li>iPhone/iPadは自動再生制限があるため「▶再生」を押すと安定します。</li>
                <li>同じWi-Fiでも「端末隔離」があると接続できません。</li>
              </ul>
            </div>
          </div>

          <div class="space-y-3">
            <div class="bg-emerald-50 border border-emerald-200 rounded-2xl p-3">
              <div class="font-black text-emerald-900">接続の流れ</div>
              <ol class="mt-2 text-sm text-emerald-800 space-y-1 list-decimal pl-5">
                <li>送信端末で「配信開始」</li>
                <li>この端末で「受信開始」</li>
                <li>自動でつながります</li>
              </ol>
            </div>

            <div class="bg-slate-50 border border-slate-200 rounded-2xl p-3 text-sm">
              <div class="font-black text-slate-700">接続状態</div>
              <div class="mt-1">Peer：<span id="recvConn" class="font-black">未接続</span></div>
            </div>

            <div class="bg-amber-50 border border-amber-200 rounded-2xl p-3 text-xs text-amber-800">
              💡 送信側が止まっていると待機になります。送信側で「配信開始」してください。
            </div>
          </div>
        </div>
      </section>
    </section>

    <div class="text-[11px] text-slate-500 px-1">
      ✅ QR/暗号化/分割なし。軽量化して「開始ボタンだけ」で接続できるようにしています。
    </div>
  </div>

<script type="module">
  // ==========================
  // Firebase（待ち合わせ用）
  // ==========================
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-app.js";
  import {
    getFirestore, doc, setDoc, updateDoc, onSnapshot, serverTimestamp, arrayUnion
  } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-firestore.js";

  // ▼▼▼ ここをあなたの Firebase 設定に置き換えてください ▼▼▼
  const firebaseConfig = {
    apiKey: "YOUR_API_KEY",
    authDomain: "YOUR_AUTH_DOMAIN",
    projectId: "YOUR_PROJECT_ID",
    storageBucket: "YOUR_STORAGE_BUCKET",
    messagingSenderId: "YOUR_MESSAGING_SENDER_ID",
    appId: "YOUR_APP_ID"
  };
  // ▲▲▲ ここまで ▲▲▲

  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);

  // 固定ルーム（あなた1人運用なら固定が一番ラク）
  const ROOM_ID = "home";
  const roomRef = doc(db, "babyMonitorRooms", ROOM_ID);

  // ==========================
  // DOM
  // ==========================
  const $ = (id) => document.getElementById(id);

  const badge = $("badge");
  const stateEl = $("state");
  const uaHint = $("uaHint");

  const btnModeSend = $("btnModeSend");
  const btnModeRecv = $("btnModeRecv");
  const sendView = $("sendView");
  const recvView = $("recvView");

  // Send
  const btnSendStart = $("btnSendStart");
  const btnSendStop = $("btnSendStop");
  const btnFlipCam = $("btnFlipCam");
  const btnMicMute = $("btnMicMute");
  const btnNightLocal = $("btnNightLocal");
  const btnTorch = $("btnTorch");
  const localVideo = $("localVideo");
  const camInfo = $("camInfo");
  const sendConn = $("sendConn");
  const btnFullLocal = $("btnFullLocal");

  // Recv
  const btnRecvStart = $("btnRecvStart");
  const btnRecvStop = $("btnRecvStop");
  const recvConn = $("recvConn");
  const remoteVideo = $("remoteVideo");
  const btnPlayRemote = $("btnPlayRemote");
  const btnSpkMute = $("btnSpkMute");
  const btnNightRemote = $("btnNightRemote");
  const btnFullAlt = $("btnFullAlt");
  const btnFullRemote = $("btnFullRemote");

  uaHint.textContent = (navigator.userAgent.includes("iPhone") || navigator.userAgent.includes("iPad"))
    ? "iOS（受信側は▶再生が必要な場合あり）"
    : "OK";

  // ==========================
  // WebRTC（LAN寄せ：STUN/TURNなし）
  // ==========================
  const pcConfig = { iceServers: [] };

  function isHostCandidate(candidateStr) {
    return / typ host /i.test(candidateStr || "");
  }

  function filterHostCandidatesInSdp(sdp) {
    const lines = (sdp || "").split(/\r\n|\n/);
    const kept = [];
    for (const line of lines) {
      if (line.startsWith("a=candidate:")) {
        if (isHostCandidate(line)) kept.push(line);
      } else {
        kept.push(line);
      }
    }
    return kept.join("\r\n").trim() + "\r\n";
  }

  async function requestVideoFullscreen(videoEl) {
    if (!videoEl) return;
    try {
      if (videoEl.requestFullscreen) await videoEl.requestFullscreen();
      else if (videoEl.webkitEnterFullscreen) videoEl.webkitEnterFullscreen();
    } catch {}
  }

  // 「固まらない」ICE収集：短時間で打ち切り
  async function gatherIceQuick(pc, maxMs = 1800) {
    const t0 = performance.now();
    let last = performance.now();
    let hasAny = false;

    const onCand = (e) => {
      if (e.candidate) { hasAny = true; last = performance.now(); }
    };
    pc.addEventListener("icecandidate", onCand);

    return new Promise((resolve) => {
      const tick = () => {
        const now = performance.now();
        const byState = pc.iceGatheringState === "complete";
        const byIdle = hasAny && (now - last > 250);
        const byMax  = (now - t0 > maxMs);
        if (byState || byIdle || byMax) {
          pc.removeEventListener("icecandidate", onCand);
          resolve();
          return;
        }
        setTimeout(tick, 140);
      };
      tick();
    });
  }

  // ==========================
  // UI helpers
  // ==========================
  function setBadge(text, tone="slate") {
    badge.textContent = text;
    const map = {
      slate: "bg-white text-slate-700 border-slate-200",
      indigo:"bg-indigo-50 text-indigo-700 border-indigo-200",
      emerald:"bg-emerald-50 text-emerald-700 border-emerald-200",
      amber:"bg-amber-50 text-amber-700 border-amber-200",
      rose:"bg-rose-50 text-rose-700 border-rose-200",
    };
    badge.className = `text-xs font-black px-3 py-1 rounded-full border ${map[tone] || map.slate}`;
  }

  function setState(text) { stateEl.textContent = text; }

  function setMode(mode) {
    if (mode === "send") {
      sendView.classList.remove("hidden");
      recvView.classList.add("hidden");
      btnModeSend.className = "p-4 rounded-3xl border border-sky-200 bg-sky-50 active:scale-[0.99] text-left";
      btnModeRecv.className = "p-4 rounded-3xl border border-slate-200 bg-white hover:bg-slate-50 active:scale-[0.99] text-left";
      setState("送信モード");
      setBadge("送信", "indigo");
    } else {
      recvView.classList.remove("hidden");
      sendView.classList.add("hidden");
      btnModeRecv.className = "p-4 rounded-3xl border border-emerald-200 bg-emerald-50 active:scale-[0.99] text-left";
      btnModeSend.className = "p-4 rounded-3xl border border-slate-200 bg-white hover:bg-slate-50 active:scale-[0.99] text-left";
      setState("受信モード");
      setBadge("受信", "emerald");
    }
  }

  btnModeSend.addEventListener("click", () => setMode("send"));
  btnModeRecv.addEventListener("click", () => setMode("recv"));
  setMode("send");

  // ==========================
  // Sender
  // ==========================
  let sendPc = null;
  let sendStream = null;
  let currentFacing = "environment";
  let micOn = true;
  let nightLocalOn = false;
  let torchOn = false;
  let unsubSendRoom = null;
  let addedCallee = new Set(); // 受信側候補の重複防止

  async function startCameraHighest() {
    const constraints = {
      audio: true,
      video: {
        facingMode: { ideal: currentFacing },
        width: { ideal: 3840 },
        height: { ideal: 2160 },
        frameRate: { ideal: 30, max: 60 }
      }
    };
    sendStream = await navigator.mediaDevices.getUserMedia(constraints);
    localVideo.srcObject = sendStream;

    const vtrack = sendStream.getVideoTracks()[0];
    const atrack = sendStream.getAudioTracks()[0];
    const s = vtrack.getSettings ? vtrack.getSettings() : {};
    camInfo.textContent = [
      `解像度：${s.width || "?"} x ${s.height || "?"}`,
      `FPS：${s.frameRate || "?"}`,
      `カメラ：${(s.facingMode || currentFacing)}`,
      `音声：${atrack ? "有効" : "なし"}`
    ].join(" / ");
  }

  function enableSendControls(on) {
    btnSendStop.disabled = !on;
    btnFlipCam.disabled = !on;
    btnMicMute.disabled = !on;
    btnNightLocal.disabled = !on;
    btnTorch.disabled = !on;
    btnFullLocal.disabled = !on;
  }

  async function stopSenderAll() {
    try { if (unsubSendRoom) unsubSendRoom(); } catch {}
    unsubSendRoom = null;

    try { if (sendPc) sendPc.close(); } catch {}
    sendPc = null;

    if (sendStream) sendStream.getTracks().forEach(t => t.stop());
    sendStream = null;

    addedCallee = new Set();

    enableSendControls(false);
    btnSendStart.disabled = false;

    micOn = true;
    btnMicMute.textContent = "🎤 マイク：ON";
    nightLocalOn = false;
    localVideo.classList.remove("night");
    btnNightLocal.textContent = "🌙 暗視：OFF";
    torchOn = false;
    btnTorch.textContent = "🔦 ライト：OFF";
    btnTorch.disabled = true;

    localVideo.srcObject = null;
    camInfo.textContent = "未開始";
    sendConn.textContent = "未接続";
    setState("送信：停止");
    setBadge("停止", "slate");
  }

  async function flipCamera() {
    currentFacing = (currentFacing === "environment") ? "user" : "environment";
    if (sendStream) sendStream.getTracks().forEach(t => t.stop());
    sendStream = null;
    await startCameraHighest();
  }

  function toggleMic() {
    if (!sendStream) return;
    const atrack = sendStream.getAudioTracks()[0];
    if (!atrack) return;
    micOn = !micOn;
    atrack.enabled = micOn;
    btnMicMute.textContent = micOn ? "🎤 マイク：ON" : "🎤 マイク：MUTE";
  }

  function toggleNightLocal() {
    nightLocalOn = !nightLocalOn;
    localVideo.classList.toggle("night", nightLocalOn);
    btnNightLocal.textContent = nightLocalOn ? "🌙 暗視：ON" : "🌙 暗視：OFF";
  }

  async function toggleTorch() {
    if (!sendStream) return;
    const vtrack = sendStream.getVideoTracks()[0];
    if (!vtrack) return;
    try {
      torchOn = !torchOn;
      await vtrack.applyConstraints({ advanced: [{ torch: torchOn }] });
      btnTorch.textContent = torchOn ? "🔦 ライト：ON" : "🔦 ライト：OFF";
      btnTorch.disabled = false;
    } catch {
      torchOn = false;
      btnTorch.textContent = "🔦 ライト：非対応";
      btnTorch.disabled = true;
    }
  }

  async function senderStart() {
    btnSendStart.disabled = true;
    setBadge("起動中…", "amber");
    setState("送信：カメラ準備中…");

    await startCameraHighest();
    enableSendControls(true);

    // ルームをリセット（古い候補を掃除）
    await setDoc(roomRef, {
      updatedAt: serverTimestamp(),
      state: "starting",
      offer: null,
      answer: null,
      callerCandidates: [],
      calleeCandidates: []
    }, { merge: false });

    sendPc = new RTCPeerConnection(pcConfig);
    sendPc.onconnectionstatechange = () => { sendConn.textContent = sendPc.connectionState; };

    // トラック追加
    sendStream.getTracks().forEach(tr => sendPc.addTrack(tr, sendStream));

    // 候補を Firestore へ（hostのみ）
    sendPc.onicecandidate = async (e) => {
      if (!e.candidate) return;
      const s = e.candidate.candidate || "";
      if (!isHostCandidate(s)) return;
      try {
        await updateDoc(roomRef, { callerCandidates: arrayUnion(e.candidate.toJSON()) });
      } catch {}
    };

    // Offer作成
    const offer = await sendPc.createOffer();
    await sendPc.setLocalDescription(offer);

    // 収集を短時間で打ち切り
    await gatherIceQuick(sendPc, 1800);

    const filteredSdp = filterHostCandidatesInSdp(sendPc.localDescription?.sdp || "");
    await updateDoc(roomRef, {
      updatedAt: serverTimestamp(),
      state: "offer",
      offer: { type: "offer", sdp: filteredSdp },
      answer: null,
      calleeCandidates: []
    });

    // 受信側の answer / candidates を監視
    unsubSendRoom = onSnapshot(roomRef, async (snap) => {
      const data = snap.data();
      if (!data) return;

      // answerが来たらセット
      if (data.answer && sendPc && !sendPc.currentRemoteDescription) {
        try {
          await sendPc.setRemoteDescription(data.answer);
          setState("送信：接続中…");
          setBadge("接続中", "indigo");
        } catch {}
      }

      // callee candidates を追加
      const arr = Array.isArray(data.calleeCandidates) ? data.calleeCandidates : [];
      for (const c of arr) {
        const key = c?.candidate || JSON.stringify(c);
        if (addedCallee.has(key)) continue;
        addedCallee.add(key);
        try { await sendPc.addIceCandidate(c); } catch {}
      }
    });

    setState("送信：配信中（受信待ち）");
    setBadge("配信中（待機）", "indigo");
    sendConn.textContent = "Answer待ち";
  }

  btnSendStart.addEventListener("click", async () => {
    try {
      await senderStart();
      btnSendStop.disabled = false;
    } catch (e) {
      alert("開始に失敗しました。Firebase設定やHTTPS、カメラ許可を確認してください。");
      btnSendStart.disabled = false;
      setBadge("エラー", "rose");
      setState("送信：エラー");
    }
  });

  btnSendStop.addEventListener("click", stopSenderAll);
  btnFlipCam.addEventListener("click", async () => { try { await flipCamera(); } catch { alert("カメラ切替に失敗しました"); } });
  btnMicMute.addEventListener("click", toggleMic);
  btnNightLocal.addEventListener("click", toggleNightLocal);
  btnTorch.addEventListener("click", toggleTorch);
  btnFullLocal.addEventListener("click", () => requestVideoFullscreen(localVideo));
  localVideo.addEventListener("dblclick", () => requestVideoFullscreen(localVideo));

  // ==========================
  // Receiver
  // ==========================
  let recvPc = null;
  let recvStream = null;
  let unsubRecvRoom = null;
  let addedCaller = new Set();
  let spkOn = true;
  let nightRemoteOn = false;

  function enableRecvControls(on) {
    btnRecvStop.disabled = !on;
    btnPlayRemote.disabled = !on;
    btnSpkMute.disabled = !on;
    btnNightRemote.disabled = !on;
    btnFullAlt.disabled = !on;
    btnFullRemote.disabled = !on;
  }

  async function stopReceiverAll() {
    try { if (unsubRecvRoom) unsubRecvRoom(); } catch {}
    unsubRecvRoom = null;

    try { if (recvPc) recvPc.close(); } catch {}
    recvPc = null;

    recvStream = null;
    remoteVideo.srcObject = null;

    addedCaller = new Set();
    enableRecvControls(false);
    btnRecvStart.disabled = false;

    spkOn = true;
    remoteVideo.muted = false;
    btnSpkMute.textContent = "🔈 音：ON";
    nightRemoteOn = false;
    remoteVideo.classList.remove("night");
    btnNightRemote.textContent = "🌙 暗視：OFF";

    recvConn.textContent = "未接続";
    setState("受信：停止");
    setBadge("停止", "slate");
  }

  async function receiverStart() {
    btnRecvStart.disabled = true;
    setBadge("待機中…", "amber");
    setState("受信：送信を待機中…");

    recvPc = new RTCPeerConnection(pcConfig);
    recvPc.onconnectionstatechange = () => { recvConn.textContent = recvPc.connectionState; };

    recvPc.ontrack = (e) => {
      if (!recvStream) recvStream = new MediaStream();
      recvStream.addTrack(e.track);
      remoteVideo.srcObject = recvStream;

      enableRecvControls(true);
      btnRecvStop.disabled = false;

      // 自動再生を試みる（iOSは失敗することあり→▶再生ボタン）
      remoteVideo.play().catch(() => {});
    };

    recvPc.onicecandidate = async (e) => {
      if (!e.candidate) return;
      const s = e.candidate.candidate || "";
      if (!isHostCandidate(s)) return;
      try {
        await updateDoc(roomRef, { calleeCandidates: arrayUnion(e.candidate.toJSON()) });
      } catch {}
    };

    // ルーム監視：offerが出たら答える
    unsubRecvRoom = onSnapshot(roomRef, async (snap) => {
      const data = snap.data();
      if (!data) return;

      // offerを受け取っていなければ待機
      if (data.offer && recvPc && !recvPc.currentRemoteDescription) {
        try {
          const sdp = filterHostCandidatesInSdp(data.offer.sdp || "");
          await recvPc.setRemoteDescription({ type: "offer", sdp });

          const answer = await recvPc.createAnswer();
          await recvPc.setLocalDescription(answer);

          await gatherIceQuick(recvPc, 1800);

          const aSdp = filterHostCandidatesInSdp(recvPc.localDescription?.sdp || "");
          await updateDoc(roomRef, {
            updatedAt: serverTimestamp(),
            state: "answer",
            answer: { type: "answer", sdp: aSdp }
          });

          setBadge("接続中", "emerald");
          setState("受信：接続中…");
        } catch {}
      }

      // caller candidates を追加
      const arr = Array.isArray(data.callerCandidates) ? data.callerCandidates : [];
      for (const c of arr) {
        const key = c?.candidate || JSON.stringify(c);
        if (addedCaller.has(key)) continue;
        addedCaller.add(key);
        try { await recvPc.addIceCandidate(c); } catch {}
      }
    });

    setBadge("待機中", "amber");
    setState("受信：送信の開始を待っています");
    recvConn.textContent = "待機";
  }

  btnRecvStart.addEventListener("click", async () => {
    try {
      await receiverStart();
      btnRecvStop.disabled = false;
    } catch {
      alert("受信開始に失敗しました。Firebase設定やHTTPSを確認してください。");
      btnRecvStart.disabled = false;
      setBadge("エラー", "rose");
      setState("受信：エラー");
    }
  });

  btnRecvStop.addEventListener("click", stopReceiverAll);

  btnPlayRemote.addEventListener("click", async () => {
    try { await remoteVideo.play(); } catch {}
  });

  btnSpkMute.addEventListener("click", () => {
    spkOn = !spkOn;
    remoteVideo.muted = !spkOn;
    btnSpkMute.textContent = spkOn ? "🔈 音：ON" : "🔇 音：MUTE";
  });

  btnNightRemote.addEventListener("click", () => {
    nightRemoteOn = !nightRemoteOn;
    remoteVideo.classList.toggle("night", nightRemoteOn);
    btnNightRemote.textContent = nightRemoteOn ? "🌙 暗視：ON" : "🌙 暗視：OFF";
  });

  btnFullAlt.addEventListener("click", () => requestVideoFullscreen(remoteVideo));
  btnFullRemote.addEventListener("click", () => requestVideoFullscreen(remoteVideo));
  remoteVideo.addEventListener("dblclick", () => requestVideoFullscreen(remoteVideo));

  // 初期状態
  enableSendControls(false);
  enableRecvControls(false);
  btnSendStop.disabled = true;
  btnRecvStop.disabled = true;
  btnTorch.disabled = true;
  sendConn.textContent = "未接続";
  recvConn.textContent = "未接続";

  // 離脱時
  window.addEventListener("beforeunload", async () => {
    await stopSenderAll();
    await stopReceiverAll();
  });

  // Firestore到達チェック（軽い）
  try {
    setBadge("OK", "slate");
  } catch {
    setBadge("設定確認", "rose");
  }
</script>
</body>
</html>
